"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const msrest = require("@azure/ms-rest-js");
const url = require("url");
const authenticationConstants_1 = require("./authenticationConstants");
/**
 * MicrosoftAppCredentials auth implementation and cache
 */
class MicrosoftAppCredentials {
    constructor(appId, appPassword, channelAuthTenant) {
        this.oAuthScope = authenticationConstants_1.AuthenticationConstants.ToChannelFromBotOAuthScope;
        this.refreshingToken = null;
        this.appId = appId;
        this.appPassword = appPassword;
        const tenant = channelAuthTenant && channelAuthTenant.length > 0
            ? channelAuthTenant
            : authenticationConstants_1.AuthenticationConstants.DefaultChannelAuthTenant;
        this.oAuthEndpoint = authenticationConstants_1.AuthenticationConstants.ToChannelFromBotLoginUrlPrefix + tenant + authenticationConstants_1.AuthenticationConstants.ToChannelFromBotTokenEndpointPath;
        this.tokenCacheKey = `${appId}-cache`;
    }
    /**
     * Adds the host of service url to trusted hosts.
     * If expiration time is not provided, the expiration date will be current (utc) date + 1 day.
     * @param  {string} serviceUrl The service url
     * @param  {Date} expiration? The expiration date after which this service url is not trusted anymore
     */
    static trustServiceUrl(serviceUrl, expiration) {
        if (!expiration) {
            expiration = new Date(Date.now() + 86400000); // 1 day
        }
        const uri = url.parse(serviceUrl);
        if (uri.host) {
            MicrosoftAppCredentials.trustedHostNames.set(uri.host, expiration);
        }
    }
    /**
     * Checks if the service url is for a trusted host or not.
     * @param  {string} serviceUrl The service url
     * @returns {boolean} True if the host of the service url is trusted; False otherwise.
     */
    static isTrustedServiceUrl(serviceUrl) {
        try {
            const uri = url.parse(serviceUrl);
            if (uri.host) {
                return MicrosoftAppCredentials.isTrustedUrl(uri.host);
            }
        }
        catch (e) {
            // tslint:disable-next-line:no-console
            console.error('Error in isTrustedServiceUrl', e);
        }
        return false;
    }
    static isTrustedUrl(uri) {
        const expiration = MicrosoftAppCredentials.trustedHostNames.get(uri);
        if (expiration) {
            // check if the trusted service url is still valid
            return expiration.getTime() > (Date.now() - 300000); // 5 Minutes
        }
        return false;
    }
    signRequest(webResource) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.shouldSetToken(webResource)) {
                const token = yield this.getToken();
                return new msrest.TokenCredentials(token).signRequest(webResource);
            }
            return webResource;
        });
    }
    getToken(forceRefresh = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!forceRefresh) {
                // check the global cache for the token. If we have it, and it's valid, we're done.
                const oAuthToken = MicrosoftAppCredentials.cache.get(this.tokenCacheKey);
                if (oAuthToken) {
                    // we have the token. Is it valid?
                    if (oAuthToken.expiration_time > Date.now()) {
                        return oAuthToken.access_token;
                    }
                }
            }
            // We need to refresh the token, because:
            // 1. The user requested it via the forceRefresh parameter
            // 2. We have it, but it's expired
            // 3. We don't have it in the cache.
            const res = yield this.refreshToken();
            this.refreshingToken = null;
            let oauthResponse;
            if (res.ok) {
                // `res` is equalivent to the results from the cached promise `this.refreshingToken`.
                // Because the promise has been cached, we need to see if the body has been read.
                // If the body has not been read yet, we can call res.json() to get the access_token.
                // If the body has been read, the OAuthResponse for that call should have been cached already,
                // in which case we can return the cache from there. If a cached OAuthResponse does not exist,
                // call getToken() again to retry the authentication process.
                if (!res.bodyUsed) {
                    oauthResponse = yield res.json();
                    // Subtract 5 minutes from expires_in so they'll we'll get a
                    // new token before it expires.
                    oauthResponse.expiration_time = Date.now() + (oauthResponse.expires_in * 1000) - 300000;
                    MicrosoftAppCredentials.cache.set(this.tokenCacheKey, oauthResponse);
                    return oauthResponse.access_token;
                }
                else {
                    const oAuthToken = MicrosoftAppCredentials.cache.get(this.tokenCacheKey);
                    if (oAuthToken) {
                        return oAuthToken.access_token;
                    }
                    else {
                        return yield this.getToken();
                    }
                }
            }
            else {
                throw new Error(res.statusText);
            }
        });
    }
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.refreshingToken) {
                const params = new FormData();
                params.append('grant_type', 'client_credentials');
                params.append('client_id', this.appId);
                params.append('client_secret', this.appPassword);
                params.append('scope', this.oAuthScope);
                this.refreshingToken = fetch(this.oAuthEndpoint, {
                    method: 'POST',
                    body: params
                });
            }
            return this.refreshingToken;
        });
    }
    shouldSetToken(webResource) {
        return MicrosoftAppCredentials.isTrustedServiceUrl(webResource.url);
    }
}
exports.MicrosoftAppCredentials = MicrosoftAppCredentials;
MicrosoftAppCredentials.trustedHostNames = new Map([
    ['state.botframework.com', new Date(8640000000000000)],
    ['api.botframework.com', new Date(8640000000000000)],
    ['token.botframework.com', new Date(8640000000000000)],
    ['state.botframework.azure.us', new Date(8640000000000000)],
    ['api.botframework.azure.us', new Date(8640000000000000)],
    ['token.botframework.azure.us', new Date(8640000000000000)],
]);
MicrosoftAppCredentials.cache = new Map();
//# sourceMappingURL=microsoftAppCredentials.js.map