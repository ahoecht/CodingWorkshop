{"version":3,"sources":["services.js"],"names":["Services","WebexPlugin","extend","namespace","_catalogs","_getCatalog","get","webex","name","priorityHost","serviceGroup","catalog","list","markFailedUrl","url","noPriorityHosts","updateServices","from","query","token","formattedQuery","status","collecting","waitForCatalog","queryKey","base64","encode","email","_fetchNewServiceHostmap","then","serviceHostMap","updateServiceUrls","updateCredentialsConfig","catch","error","reject","validateUser","reqId","skipEmail","Error","canAuthorize","credentials","sendUserActivation","request","service","resource","method","headers","accept","authorization","toString","undefined","body","shouldRefreshAccessToken","resolve","getUserToken","activated","exists","details","user","config","client_id","client_secret","output","collectPreauthCatalog","getClientToken","uri","scope","tokenObj","collectSigninCatalog","idbroker","identity","setConfig","slice","timeout","postauth","_formatReceivedHostmap","serviceHostmap","formattedHostmap","hostCatalog","reduce","accumulator","key","length","serviceName","id","split","defaultUrl","serviceLinks","serviceItem","find","item","defaultHost","Url","parse","hostname","hosts","push","host","ttl","priority","homeCluster","map","forEach","getClusterId","findClusterId","getServiceFromClusterId","params","findServiceFromClusterId","isServiceUrl","findServiceUrlFromUrl","qs","format","requestObject","initialize","ServiceCatalog","set","listenToOnce","mappedServices","services","logger","warn"],"mappings":"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","file":"services.js","sourcesContent":["import Url from 'url';\n\nimport {base64} from '@webex/common';\n\nimport WebexPlugin from '../webex-plugin';\n\nimport ServiceCatalog from './service-catalog';\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst Services = WebexPlugin.extend({\n  namespace: 'Services',\n\n  _catalogs: new WeakMap(),\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices({from, query, token} = {}) {\n    const catalog = this._getCatalog();\n    let formattedQuery, serviceGroup;\n\n    // map catalog name to service group name.\n    switch (from) {\n      case 'limited': serviceGroup = 'preauth'; break;\n      case 'signin': serviceGroup = 'signin'; break;\n      default: serviceGroup = 'postauth'; break;\n    }\n\n    // confirm catalog update for group is not in progress.\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    // encode email when query key is email\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      const queryKey = Object.keys(query)[0];\n\n      formattedQuery = {};\n      formattedQuery[queryKey] = queryKey === 'email' ?\n        base64.encode(query.email) : query[queryKey];\n    }\n\n    return this._fetchNewServiceHostmap({\n      from,\n      token,\n      query: formattedQuery\n    })\n      .then((serviceHostMap) => {\n        catalog.updateServiceUrls(serviceGroup, serviceHostMap);\n        this.updateCredentialsConfig();\n        catalog.status[serviceGroup].collecting = false;\n      })\n      .catch((error) => {\n        catalog.status[serviceGroup].collecting = false;\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * User validation parameter object for {@link validateUser}.\n   * @typedef {object} userValidationParamObject\n   * @property {string} email - must be a standard-format email\n   * @property {string} [reqId] - request id\n   * @property {boolean} [skipEmail] - skips the atlas request if true\n   */\n\n  /**\n   * User validation return object for {@link validateUser}\n   * @typedef {object} userValidationReturnObject\n   * @property {boolean} activated - if user has been activated\n   * @property {boolean} exists - if user has been created and exists\n   * @property {string} details - message containing brief description\n   * @property {object} user - user object returned from atlas\n   */\n\n  /**\n   * Validate if a user, by email, is activated or not. This also returns\n   * an object that contains the atlas user details if available. Currently,\n   * this method has a parameter key for skipping Atlas activation. Once we\n   * have improved our test user package, this will most likely be removed.\n   * @param {userValidationParamObject} params\n   * @returns {Promise<userValidationReturnObject>}\n   */\n  validateUser({email, reqId = 'WEBCLIENT', skipEmail} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n\n    const {canAuthorize} = this.webex.credentials;\n\n    // Scoped function for sending the atlas\n    // activation request.\n    const sendUserActivation = (token) => {\n      if (!skipEmail) {\n        return this.request({\n          service: 'atlas',\n          resource: 'users/activations',\n          method: 'POST',\n          headers: {\n            accept: 'application/json',\n            authorization: token.toString(),\n            'x-prelogin-userid': undefined\n          },\n          body: {email, reqId},\n          shouldRefreshAccessToken: false\n        });\n      }\n\n      return Promise.resolve({body: {}});\n    };\n\n    // This conditional statement exists as a logical\n    // fallback in the event that the user is already\n    // authorized via a user token.\n    if (canAuthorize) {\n      return this.updateServices()\n        .then(() => this.webex.credentials.getUserToken())\n        .then((token) => sendUserActivation(token))\n        .then(({body}) => ({\n          activated: true,\n          exists: true,\n          details: 'user is authorized via user token',\n          user: body\n        }));\n    }\n\n    // Begin unauth user signin process.\n    /* eslint-disable camelcase */\n    const {client_id, client_secret} = this.webex.credentials.config;\n\n    if (!client_id || !client_secret) {\n      return Promise.reject(\n        new Error('`client_id` or `client_secret` is not defined')\n      );\n    }\n    /* eslint-enable camelcase */\n\n    let token, output;\n\n    return this.collectPreauthCatalog({email})\n      .then(() => this.webex.credentials.getClientToken({\n        // Core doesn't utilize the service plugin by default.\n        // Inject the required uri via string literal.\n        uri: `${this.get('idbroker', true, 'preauth')}idb/oauth2/v1/access_token`,\n        scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'\n      }))\n      .then((tokenObj) => {\n        token = tokenObj;\n\n        return this.collectSigninCatalog({email, token: token.toString()});\n      })\n      // If signin catalog does not return 2xx\n      .catch((error) => {\n        output = {\n          exists: (error.name !== 'NotFound'),\n          activated: false,\n          details: (error.name !== 'NotFound') ?\n            'user exists but is not activated' :\n            'user does not exist and is not activated'\n        };\n      })\n      // send activation / signin\n      .then(() => {\n        output = output || {\n          activated: true,\n          exists: true,\n          details: 'user exists and is activated'\n        };\n\n        return sendUserActivation(token);\n      })\n      .then(({body}) => ({...output, user: body}));\n  },\n\n\n  /**\n   * simplified method to update the preauth catalog via email\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog({email} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n\n    return this.updateServices({from: 'limited', query: {email}});\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog({email, token} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n    if (!token) {\n      return Promise.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({from: 'signin', query: {email}, token});\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig() {\n    const {idbroker, identity} = this.list(true);\n\n    if (idbroker && identity) {\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.slice(0, -1) // remove trailing slash\n          },\n          identity: {\n            url: identity.slice(0, -1) // remove trailing slash\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    const catalog = this._getCatalog();\n\n    if (serviceGroup === 'postauth' &&\n      this.webex.credentials.canAuthorize &&\n      !catalog.status.postauth.collecting\n    ) {\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * catalog endpoint.\n   * @param {object} serviceHostmap\n   * @returns {object}\n   */\n  _formatReceivedHostmap(serviceHostmap) {\n    // map the host catalog items to a formatted hostmap\n    const formattedHostmap = Object.keys(serviceHostmap.hostCatalog).reduce(\n      (accumulator, key) => {\n        if (serviceHostmap.hostCatalog[key].length === 0) {\n          return accumulator;\n        }\n\n        const serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];\n        const defaultUrl = serviceHostmap.serviceLinks[serviceName];\n\n        let serviceItem = accumulator.find(\n          (item) => item.name === serviceName\n        );\n\n        if (!serviceItem) {\n          serviceItem = {\n            name: serviceName,\n            defaultUrl,\n            defaultHost: Url.parse(defaultUrl).hostname,\n            hosts: []\n          };\n\n          accumulator.push(serviceItem);\n        }\n\n        serviceItem.hosts.push(\n          // map the default key as a low priority default for cluster matching\n          {\n            host: key,\n            ttl: -1,\n            priority: 10,\n            id: serviceHostmap.hostCatalog[key][0].id,\n            homeCluster: serviceItem.defaultHost === key\n          },\n          // map the rest of the hosts in their proper locations\n          ...serviceHostmap.hostCatalog[key].map(\n            (host) => ({\n              ...host,\n              homeCluster: serviceItem.defaultHost === key\n            })\n          )\n        );\n\n        return accumulator;\n      }, []\n    );\n\n    // append service links that do not exist in the host catalog\n    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {\n      const service = formattedHostmap.find((item) => item.name === key);\n\n      if (!service) {\n        formattedHostmap.push({\n          name: key,\n          defaultUrl: serviceHostmap.serviceLinks[key],\n          defaultHost: Url.parse(serviceHostmap.serviceLinks[key]).hostname,\n          hosts: []\n        });\n      }\n    });\n\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId(url) {\n    const catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId(params) {\n    const catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * Verify that a provided url exists in the service\n   * catalog.\n   * @param {string} url\n   * @returns {boolean} - true if exists, false otherwise\n   */\n  isServiceUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findServiceUrlFromUrl(url));\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap({from, query, token} = {}) {\n    const service = 'u2c';\n    const resource = from ? `/${from}/catalog` : '/catalog';\n    const qs = {...query, format: 'hostmap'};\n\n    const requestObject = {\n      method: 'GET', service, resource, qs\n    };\n\n    if (token) {\n      requestObject.headers = {authorization: token};\n    }\n\n    return this.request(requestObject)\n      .then(({body}) => this._formatReceivedHostmap(body));\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize() {\n    const catalog = new ServiceCatalog();\n\n    this._catalogs.set(this.webex, catalog);\n\n    // once config has changed, begin initialization\n    this.listenToOnce(this.webex, 'change:config', () => {\n      // format services config object into an array\n      const mappedServices = Object.keys(this.webex.config.services)\n        .map((key) => ({\n          name: key,\n          defaultUrl: this.webex.config.services[key]\n        }));\n\n      // inject formatted services into services catalog\n      catalog.updateServiceUrls('discovery', mappedServices);\n    });\n\n    // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n    this.listenToOnce(this.webex, 'ready', () => {\n      /* eslint-disable camelcase */\n      if (this.webex.credentials.canAuthorize) {\n        this.updateServices()\n        // this catch prevents crashing in unique situations found\n        // primarily in unit testing with the karma suite.\n          .catch(\n            () => this.logger.warn('services: catalog retrieval failed w/auth')\n          );\n      }\n      else if (this.webex.config.email) {\n        this.updateServices({\n          catalog: 'limited',\n          query: {email: this.webex.config.email}\n        });\n      }\n      /* eslint-enable camelcase */\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default Services;\n"]}