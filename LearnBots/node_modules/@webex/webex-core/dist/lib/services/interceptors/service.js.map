{"version":3,"sources":["service.js"],"names":["trailingSlashes","ServiceInterceptor","options","services","webex","internal","service","tags","serviceInterceptor","resource","get","catalog","validateOptions","uri","generateUrl","credentials","canAuthorize","waitForCatalog","then","Error","resolve","catch","e","reject","formattedService","replace","formattedResource","Interceptor"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;AAEA,IAAMA,kBAAkB,iBAAxB;;AAEA;;;AARA;;;;IAWqBC,kB;;;;;;;;;;;;AASnB;AACA;;;;;8BAKUC,O,EAAS;AAAA;;AAAA,UACVC,QADU,GACE,KAAKC,KAAL,CAAWC,QADb,CACVF,QADU;;AAEjB,UAAIG,gBAAJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAI,CAACJ,QAAQK,IAAb,EAAmB;AAAEL,gBAAQK,IAAR,GAAe,EAAf;AAAoB;;AAEzC;AACA;AACA,UAAI,CAACL,QAAQK,IAAR,CAAaC,kBAAlB,EAAsC;AACpCN,gBAAQK,IAAR,CAAaC,kBAAb,GAAkC,IAAlC;;AAEA;AACA;AACA;AACA;AACA,YAAI,CAACN,QAAQI,OAAT,IAAoB,CAACJ,QAAQO,QAAjC,EAA2C;AACzC,iBAAOP,OAAP;AACD;;AAEDI,kBAAUH,SAASO,GAAT,CAAaR,QAAQI,OAArB,EAA8B,IAA9B,EAAoCJ,QAAQS,OAA5C,CAAV;;AAEA,YAAIL,OAAJ,EAAa;AACX,eAAKM,eAAL,CAAqBV,OAArB;;AAEAA,kBAAQW,GAAR,GAAc,KAAKC,WAAL,CAAiBR,OAAjB,EAA0BJ,QAAQO,QAAlC,CAAd;;AAEA,iBAAOP,OAAP;AACD;;AAED,YAAI,KAAKE,KAAL,CAAWW,WAAX,CAAuBC,YAA3B,EAAyC;AACvC,iBAAOb,SAASc,cAAT,CAAwB,UAAxB,EAAoC,EAApC,EACJC,IADI,CACC,YAAM;AACV,mBAAKN,eAAL,CAAqBV,OAArB;;AAEAI,sBAAUH,SAASO,GAAT,CAAaR,QAAQI,OAArB,EAA8B,IAA9B,EAAoCJ,QAAQS,OAA5C,CAAV;AACA,gBAAI,CAACL,OAAD,IAAYJ,QAAQW,GAAxB,EAA6B;AAC3B,qBAAOX,OAAP;AACD;;AAED,gBAAI,CAACI,OAAL,EAAc;AACZ,oBAAM,IAAIa,KAAJ,OAAejB,QAAQI,OAAvB,8BAAN;AACD;;AAEDJ,oBAAQW,GAAR,GAAc,OAAKC,WAAL,CAAiBR,OAAjB,EAA0BJ,QAAQO,QAAlC,CAAd;;AAEA,mBAAO,kBAAQW,OAAR,CAAgBlB,OAAhB,CAAP;AACD,WAhBI,EAiBJmB,KAjBI,CAiBE,UAACC,CAAD;AAAA,mBAAO,kBAAQC,MAAR,CAAeD,CAAf,CAAP;AAAA,WAjBF,CAAP;AAkBD;AACF;;AAED,aAAOpB,OAAP;AACD;AACD;;AAEA;AACA;;;;;;;;;oCAMgBA,O,EAAS;AACvB;AACA,UAAI,CAACA,QAAQO,QAAb,EAAuB;AACrB,cAAM,IAAIU,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED;AACA,UAAI,CAACjB,QAAQI,OAAT,IAAoB,CAACJ,QAAQW,GAAjC,EAAsC;AACpC,cAAM,IAAIM,KAAJ,CAAU,kDAAV,CAAN;AACD;AACF;;AAED;;;;;;;;;gCAMYb,O,EAASG,Q,EAAU;AAC7B,UAAMe,mBAAmBlB,QAAQmB,OAAR,CAAgBzB,eAAhB,EAAiC,EAAjC,CAAzB;AACA,UAAM0B,oBAAoBjB,SAASgB,OAAT,CAAiBzB,eAAjB,EAAkC,EAAlC,CAA1B;;AAEA,aAAUwB,gBAAV,SAA8BE,iBAA9B;AACD;AACD;;;;;AA1GA;;;6BAGgB;AACd;AACA,aAAO,IAAIzB,kBAAJ,CAAuB,EAACG,OAAO,IAAR,EAAvB,CAAP;AACD;;;EAP6CuB,qB;;kBAA3B1B,kB","file":"service.js","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\nconst trailingSlashes = /(?:^\\/)|(?:\\/$)/;\n\n/**\n * @class\n */\nexport default class ServiceInterceptor extends Interceptor {\n  /**\n   * @returns {ServiceInterceptor}\n   */\n  static create() {\n    /* eslint no-invalid-this: [0] */\n    return new ServiceInterceptor({webex: this});\n  }\n\n  /* eslint-disable no-param-reassign */\n  /**\n   * @see Interceptor#onRequest\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    const {services} = this.webex.internal;\n    let service;\n\n    // Populate option object's tag key.\n    // A later PR will handle generating these tags at\n    // request construction. These tags are used to validate\n    // if a request has already been handled by a specific\n    // interceptor. This is useful when multiple interceptors\n    // operate on the same options object keys.\n    if (!options.tags) { options.tags = {}; }\n\n    // If an operation hasn't been made via\n    // this interceptor...\n    if (!options.tags.serviceInterceptor) {\n      options.tags.serviceInterceptor = true;\n\n      // Some plugins are sending requests directly via the\n      // `uri` key. To not conflict with the `internal-plugin-wdm`\n      // interceptors, we need to check the following two key values\n      // to confirm an operation needs to be made.\n      if (!options.service && !options.resource) {\n        return options;\n      }\n\n      service = services.get(options.service, true, options.catalog);\n\n      if (service) {\n        this.validateOptions(options);\n\n        options.uri = this.generateUrl(service, options.resource);\n\n        return options;\n      }\n\n      if (this.webex.credentials.canAuthorize) {\n        return services.waitForCatalog('postauth', 20)\n          .then(() => {\n            this.validateOptions(options);\n\n            service = services.get(options.service, true, options.catalog);\n            if (!service && options.uri) {\n              return options;\n            }\n\n            if (!service) {\n              throw new Error(`\\`${options.service}\\` is not a known service`);\n            }\n\n            options.uri = this.generateUrl(service, options.resource);\n\n            return Promise.resolve(options);\n          })\n          .catch((e) => Promise.reject(e));\n      }\n    }\n\n    return options;\n  }\n  /* eslint-enable no-param-reassign */\n\n  /* eslint-disable class-methods-use-this */\n  /**\n   * Verify that all required parameters have been specified.\n   * @param {object} options\n   * @param {string} options.resource\n   * @returns {void}\n   */\n  validateOptions(options) {\n    // Validate a resource is present in the options object.\n    if (!options.resource) {\n      throw new Error('a `resource` parameter is required');\n    }\n\n    // Validate either uri or service is present in the options object.\n    if (!options.service && !options.uri) {\n      throw new Error('a valid `service` or `uri` parameter is required');\n    }\n  }\n\n  /**\n   * Safely generate a usable request uri string.\n   * @param {string} service\n   * @param {string} resource\n   * @returns {boolean}\n   */\n  generateUrl(service, resource) {\n    const formattedService = service.replace(trailingSlashes, '');\n    const formattedResource = resource.replace(trailingSlashes, '');\n\n    return `${formattedService}/${formattedResource}`;\n  }\n  /* eslint-enable class-methods-use-this */\n}\n"]}