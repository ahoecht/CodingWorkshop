'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _common = require('@webex/common');

var _webexPlugin = require('../webex-plugin');

var _webexPlugin2 = _interopRequireDefault(_webexPlugin);

var _serviceCatalog = require('./service-catalog');

var _serviceCatalog2 = _interopRequireDefault(_serviceCatalog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-underscore-dangle */
/**
 * @class
 */
var Services = _webexPlugin2.default.extend({
  namespace: 'Services',

  _catalogs: new _weakMap2.default(),

  /**
   * @private
   * Get the current catalog based on the assocaited
   * webex instance.
   * @returns {ServiceCatalog}
   */
  _getCatalog: function _getCatalog() {
    return this._catalogs.get(this.webex);
  },


  /**
   * Get a service url from the current services list by name
   * from the associated instance catalog.
   * @param {string} name
   * @param {boolean} [priorityHost]
   * @param {string} [serviceGroup]
   * @returns {string|undefined}
   */
  get: function get(name, priorityHost, serviceGroup) {
    var catalog = this._getCatalog();

    return catalog.get(name, priorityHost, serviceGroup);
  },


  /**
   * Generate a service catalog as an object from
   * the associated instance catalog.
   * @param {boolean} [priorityHost] - use highest priority host if set to `true`
   * @param {string} [serviceGroup]
   * @returns {Record<string, string>}
   */
  list: function list(priorityHost, serviceGroup) {
    var catalog = this._getCatalog();

    return catalog.list(priorityHost, serviceGroup);
  },


  /**
   * Mark a priority host service url as failed.
   * This will mark the host associated with the
   * `ServiceUrl` to be removed from the its
   * respective host array, and then return the next
   * viable host from the `ServiceUrls` host array,
   * or the `ServiceUrls` default url if no other priority
   * hosts are available, or if `noPriorityHosts` is set to
   * `true`.
   * @param {string} url
   * @param {boolean} noPriorityHosts
   * @returns {string}
   */
  markFailedUrl: function markFailedUrl(url, noPriorityHosts) {
    var catalog = this._getCatalog();

    return catalog.markFailedUrl(url, noPriorityHosts);
  },


  /**
   * Update a list of `serviceUrls` to the most current
   * catalog via the defined `discoveryUrl` then returns the current
   * list of services.
   * @param {object} [param]
   * @param {string} [param.from] - This accepts `limited` or `signin`
   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values
   * @param {string} [param.query.email] - must be a standard-format email
   * @param {string} [param.query.orgId] - must be an organization id
   * @param {string} [param.query.userId] - must be a user id
   * @param {string} [param.token] - used for signin catalog
   * @returns {Promise<object>}
   */
  updateServices: function updateServices() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        from = _ref.from,
        query = _ref.query,
        token = _ref.token;

    var catalog = this._getCatalog();
    var formattedQuery = void 0,
        serviceGroup = void 0;

    // map catalog name to service group name.
    switch (from) {
      case 'limited':
        serviceGroup = 'preauth';break;
      case 'signin':
        serviceGroup = 'signin';break;
      default:
        serviceGroup = 'postauth';break;
    }

    // confirm catalog update for group is not in progress.
    if (catalog.status[serviceGroup].collecting) {
      return this.waitForCatalog(serviceGroup);
    }

    catalog.status[serviceGroup].collecting = true;

    // encode email when query key is email
    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {
      var queryKey = (0, _keys2.default)(query)[0];

      formattedQuery = {};
      formattedQuery[queryKey] = queryKey === 'email' ? _common.base64.encode(query.email) : query[queryKey];
    }

    return this._fetchNewServiceHostmap({
      from: from,
      token: token,
      query: formattedQuery
    }).then(function (serviceHostMap) {
      catalog.updateServiceUrls(serviceGroup, serviceHostMap);
      _this.updateCredentialsConfig();
      catalog.status[serviceGroup].collecting = false;
    }).catch(function (error) {
      catalog.status[serviceGroup].collecting = false;

      return _promise2.default.reject(error);
    });
  },


  /**
   * User validation parameter object for {@link validateUser}.
   * @typedef {object} userValidationParamObject
   * @property {string} email - must be a standard-format email
   * @property {string} [reqId] - request id
   * @property {boolean} [skipEmail] - skips the atlas request if true
   */

  /**
   * User validation return object for {@link validateUser}
   * @typedef {object} userValidationReturnObject
   * @property {boolean} activated - if user has been activated
   * @property {boolean} exists - if user has been created and exists
   * @property {string} details - message containing brief description
   * @property {object} user - user object returned from atlas
   */

  /**
   * Validate if a user, by email, is activated or not. This also returns
   * an object that contains the atlas user details if available. Currently,
   * this method has a parameter key for skipping Atlas activation. Once we
   * have improved our test user package, this will most likely be removed.
   * @param {userValidationParamObject} params
   * @returns {Promise<userValidationReturnObject>}
   */
  validateUser: function validateUser() {
    var _this2 = this;

    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        email = _ref2.email,
        _ref2$reqId = _ref2.reqId,
        reqId = _ref2$reqId === undefined ? 'WEBCLIENT' : _ref2$reqId,
        skipEmail = _ref2.skipEmail;

    if (!email) {
      return _promise2.default.reject(new Error('`email` is required'));
    }

    var canAuthorize = this.webex.credentials.canAuthorize;

    // Scoped function for sending the atlas
    // activation request.

    var sendUserActivation = function sendUserActivation(token) {
      if (!skipEmail) {
        return _this2.request({
          service: 'atlas',
          resource: 'users/activations',
          method: 'POST',
          headers: {
            accept: 'application/json',
            authorization: token.toString(),
            'x-prelogin-userid': undefined
          },
          body: { email: email, reqId: reqId },
          shouldRefreshAccessToken: false
        });
      }

      return _promise2.default.resolve({ body: {} });
    };

    // This conditional statement exists as a logical
    // fallback in the event that the user is already
    // authorized via a user token.
    if (canAuthorize) {
      return this.updateServices().then(function () {
        return _this2.webex.credentials.getUserToken();
      }).then(function (token) {
        return sendUserActivation(token);
      }).then(function (_ref3) {
        var body = _ref3.body;
        return {
          activated: true,
          exists: true,
          details: 'user is authorized via user token',
          user: body
        };
      });
    }

    // Begin unauth user signin process.
    /* eslint-disable camelcase */
    var _webex$credentials$co = this.webex.credentials.config,
        client_id = _webex$credentials$co.client_id,
        client_secret = _webex$credentials$co.client_secret;


    if (!client_id || !client_secret) {
      return _promise2.default.reject(new Error('`client_id` or `client_secret` is not defined'));
    }
    /* eslint-enable camelcase */

    var token = void 0,
        output = void 0;

    return this.collectPreauthCatalog({ email: email }).then(function () {
      return _this2.webex.credentials.getClientToken({
        // Core doesn't utilize the service plugin by default.
        // Inject the required uri via string literal.
        uri: _this2.get('idbroker', true, 'preauth') + 'idb/oauth2/v1/access_token',
        scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'
      });
    }).then(function (tokenObj) {
      token = tokenObj;

      return _this2.collectSigninCatalog({ email: email, token: token.toString() });
    })
    // If signin catalog does not return 2xx
    .catch(function (error) {
      output = {
        exists: error.name !== 'NotFound',
        activated: false,
        details: error.name !== 'NotFound' ? 'user exists but is not activated' : 'user does not exist and is not activated'
      };
    })
    // send activation / signin
    .then(function () {
      output = output || {
        activated: true,
        exists: true,
        details: 'user exists and is activated'
      };

      return sendUserActivation(token);
    }).then(function (_ref4) {
      var body = _ref4.body;
      return (0, _extends3.default)({}, output, { user: body });
    });
  },


  /**
   * simplified method to update the preauth catalog via email
   * @param {object} param
   * @param {string} param.email - must be a standard-format email
   * @returns {Promise<void>}
   */
  collectPreauthCatalog: function collectPreauthCatalog() {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        email = _ref5.email;

    if (!email) {
      return _promise2.default.reject(new Error('`email` is required'));
    }

    return this.updateServices({ from: 'limited', query: { email: email } });
  },


  /**
   * simplified method to update the signin catalog via email and token
   * @param {object} param
   * @param {string} param.email - must be a standard-format email
   * @param {string} param.token - must be a client token
   * @returns {Promise<void>}
   */
  collectSigninCatalog: function collectSigninCatalog() {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        email = _ref6.email,
        token = _ref6.token;

    if (!email) {
      return _promise2.default.reject(new Error('`email` is required'));
    }
    if (!token) {
      return _promise2.default.reject(new Error('`token` is required'));
    }

    return this.updateServices({ from: 'signin', query: { email: email }, token: token });
  },


  /**
   * Updates credentials config to utilize u2c catalog
   * urls.
   * @returns {void}
   */
  updateCredentialsConfig: function updateCredentialsConfig() {
    var _list = this.list(true),
        idbroker = _list.idbroker,
        identity = _list.identity;

    if (idbroker && identity) {
      this.webex.setConfig({
        credentials: {
          idbroker: {
            url: idbroker.slice(0, -1) // remove trailing slash
          },
          identity: {
            url: identity.slice(0, -1) // remove trailing slash
          }
        }
      });
    }
  },


  /**
   * Wait until the service catalog is available,
   * or reject afte ra timeout of 60 seconds.
   * @param {string} serviceGroup
   * @param {number} [timeout] - in seconds
   * @returns {Promise<void>}
   */
  waitForCatalog: function waitForCatalog(serviceGroup, timeout) {
    var catalog = this._getCatalog();

    if (serviceGroup === 'postauth' && this.webex.credentials.canAuthorize && !catalog.status.postauth.collecting) {
      return this.updateServices();
    }

    return catalog.waitForCatalog(serviceGroup, timeout);
  },


  /**
   * @private
   * Organize a received hostmap from a service
   * catalog endpoint.
   * @param {object} serviceHostmap
   * @returns {object}
   */
  _formatReceivedHostmap: function _formatReceivedHostmap(serviceHostmap) {
    // map the host catalog items to a formatted hostmap
    var formattedHostmap = (0, _keys2.default)(serviceHostmap.hostCatalog).reduce(function (accumulator, key) {
      var _serviceItem$hosts;

      if (serviceHostmap.hostCatalog[key].length === 0) {
        return accumulator;
      }

      var serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];
      var defaultUrl = serviceHostmap.serviceLinks[serviceName];

      var serviceItem = accumulator.find(function (item) {
        return item.name === serviceName;
      });

      if (!serviceItem) {
        serviceItem = {
          name: serviceName,
          defaultUrl: defaultUrl,
          defaultHost: _url2.default.parse(defaultUrl).hostname,
          hosts: []
        };

        accumulator.push(serviceItem);
      }

      (_serviceItem$hosts = serviceItem.hosts).push.apply(_serviceItem$hosts, [
      // map the default key as a low priority default for cluster matching
      {
        host: key,
        ttl: -1,
        priority: 10,
        id: serviceHostmap.hostCatalog[key][0].id,
        homeCluster: serviceItem.defaultHost === key
      }].concat((0, _toConsumableArray3.default)(serviceHostmap.hostCatalog[key].map(function (host) {
        return (0, _extends3.default)({}, host, {
          homeCluster: serviceItem.defaultHost === key
        });
      }))));

      return accumulator;
    }, []);

    // append service links that do not exist in the host catalog
    (0, _keys2.default)(serviceHostmap.serviceLinks).forEach(function (key) {
      var service = formattedHostmap.find(function (item) {
        return item.name === key;
      });

      if (!service) {
        formattedHostmap.push({
          name: key,
          defaultUrl: serviceHostmap.serviceLinks[key],
          defaultHost: _url2.default.parse(serviceHostmap.serviceLinks[key]).hostname,
          hosts: []
        });
      }
    });

    return formattedHostmap;
  },


  /**
   * Get the clusterId associated with a URL string.
   * @param {string} url
   * @returns {string} - Cluster ID of url provided
   */
  getClusterId: function getClusterId(url) {
    var catalog = this._getCatalog();

    return catalog.findClusterId(url);
  },


  /**
   * Get a service value from a provided clusterId. This method will
   * return an object containing both the name and url of a found service.
   * @param {object} params
   * @param {string} params.clusterId - clusterId of found service
   * @param {boolean} [params.priorityHost] - returns priority host url if true
   * @param {string} [params.serviceGroup] - specify service group
   * @returns {object} service
   * @returns {string} service.name
   * @returns {string} service.url
   */
  getServiceFromClusterId: function getServiceFromClusterId(params) {
    var catalog = this._getCatalog();

    return catalog.findServiceFromClusterId(params);
  },


  /**
   * Verify that a provided url exists in the service
   * catalog.
   * @param {string} url
   * @returns {boolean} - true if exists, false otherwise
   */
  isServiceUrl: function isServiceUrl(url) {
    var catalog = this._getCatalog();

    return !!catalog.findServiceUrlFromUrl(url);
  },


  /**
   * @private
   * Simplified method wrapper for sending a request to get
   * an updated service hostmap.
   * @param {object} [param]
   * @param {string} [param.from] - This accepts `limited` or `signin`
   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values
   * @param {string} [param.query.email] - must be a standard-format email
   * @param {string} [param.query.orgId] - must be an organization id
   * @param {string} [param.query.userId] - must be a user id
   * @param {string} [param.token] - used for signin catalog
   * @returns {Promise<object>}
   */
  _fetchNewServiceHostmap: function _fetchNewServiceHostmap() {
    var _this3 = this;

    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        from = _ref7.from,
        query = _ref7.query,
        token = _ref7.token;

    var service = 'u2c';
    var resource = from ? '/' + from + '/catalog' : '/catalog';
    var qs = (0, _extends3.default)({}, query, { format: 'hostmap' });

    var requestObject = {
      method: 'GET', service: service, resource: resource, qs: qs
    };

    if (token) {
      requestObject.headers = { authorization: token };
    }

    return this.request(requestObject).then(function (_ref8) {
      var body = _ref8.body;
      return _this3._formatReceivedHostmap(body);
    });
  },


  /**
   * Initializer
   *
   * @instance
   * @memberof Services
   * @returns {Services}
   */
  initialize: function initialize() {
    var _this4 = this;

    var catalog = new _serviceCatalog2.default();

    this._catalogs.set(this.webex, catalog);

    // once config has changed, begin initialization
    this.listenToOnce(this.webex, 'change:config', function () {
      // format services config object into an array
      var mappedServices = (0, _keys2.default)(_this4.webex.config.services).map(function (key) {
        return {
          name: key,
          defaultUrl: _this4.webex.config.services[key]
        };
      });

      // inject formatted services into services catalog
      catalog.updateServiceUrls('discovery', mappedServices);
    });

    // wait for webex instance to be ready before attempting
    // to update the service catalogs
    this.listenToOnce(this.webex, 'ready', function () {
      /* eslint-disable camelcase */
      if (_this4.webex.credentials.canAuthorize) {
        _this4.updateServices()
        // this catch prevents crashing in unique situations found
        // primarily in unit testing with the karma suite.
        .catch(function () {
          return _this4.logger.warn('services: catalog retrieval failed w/auth');
        });
      } else if (_this4.webex.config.email) {
        _this4.updateServices({
          catalog: 'limited',
          query: { email: _this4.webex.config.email }
        });
      }
      /* eslint-enable camelcase */
    });
  },
  version: '1.80.45'
});
/* eslint-enable no-underscore-dangle */

exports.default = Services;
//# sourceMappingURL=services.js.map
