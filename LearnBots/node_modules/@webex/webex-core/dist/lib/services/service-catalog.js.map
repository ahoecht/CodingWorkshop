{"version":3,"sources":["service-catalog.js"],"names":["ServiceCatalog","AmpState","extend","namespace","props","serviceGroups","discovery","preauth","signin","postauth","status","ready","collecting","_getUrl","name","serviceGroup","serviceUrls","find","serviceUrl","_listServiceUrls","_loadServiceUrls","services","existingService","forEach","service","push","_unloadServiceUrls","splice","indexOf","findClusterId","url","incomingUrlObj","Url","parse","clusterId","serviceUrlObj","key","defaultUrl","hostname","hosts","length","id","host","findServiceFromClusterId","priorityHost","identifiedServiceUrl","get","undefined","findServiceUrlFromUrl","list","output","markFailedUrl","noPriorityHosts","removeHost","updateServiceUrls","serviceHostmap","currentServiceUrls","unusedUrls","filter","every","item","serviceObj","ServiceUrl","trigger","waitForCatalog","timeout","resolve","reject","timeoutTimer","setTimeout","Error","once","clearTimeout"],"mappings":"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","file":"service-catalog.js","sourcesContent":["import Url from 'url';\n\nimport AmpState from 'ampersand-state';\n\nimport ServiceUrl from './service-url';\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst ServiceCatalog = AmpState.extend({\n  namespace: 'ServiceCatalog',\n\n  props: {\n    serviceGroups: ['object', true, (() => ({\n      discovery: [],\n      preauth: [],\n      signin: [],\n      postauth: []\n    }))],\n    status: ['object', true, (() => ({\n      discovery: {\n        ready: false,\n        collecting: false\n      },\n      preauth: {\n        ready: false,\n        collecting: false\n      },\n      postauth: {\n        ready: false,\n        collecting: false\n      },\n      signin: {\n        ready: false,\n        collecting: false\n      }\n    }))]\n  },\n\n  /**\n   * @private\n   * Search the service url array to locate a `ServiceUrl`\n   * class object based on its name.\n   * @param {string} name\n   * @param {string} [serviceGroup]\n   * @returns {ServiceUrl}\n   */\n  _getUrl(name, serviceGroup) {\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] :\n      [\n        ...this.serviceGroups.postauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.discovery\n      ];\n\n    return serviceUrls.find((serviceUrl) => serviceUrl.name === name);\n  },\n\n  /**\n   * @private\n   * Generate an array of `ServiceUrl`s that is organized from highest auth\n   * level to lowest auth level.\n   * @returns {Array<ServiceUrl>} - array of `ServiceUrl`s\n   */\n  _listServiceUrls() {\n    return [\n      ...this.serviceGroups.postauth,\n      ...this.serviceGroups.signin,\n      ...this.serviceGroups.preauth,\n      ...this.serviceGroups.discovery\n    ];\n  },\n\n  /**\n   * @private\n   * Safely load one or more `ServiceUrl`s into this `Services` instance.\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _loadServiceUrls(serviceGroup, services) {\n    // declare namespaces outside of loop\n    let existingService;\n\n    services.forEach((service) => {\n      existingService = this._getUrl(service.name, serviceGroup);\n\n      if (!existingService) {\n        this.serviceGroups[serviceGroup].push(service);\n      }\n    });\n\n    return this;\n  },\n\n  /**\n   * @private\n   * Safely unload one or more `ServiceUrl`s into this `Services` instance\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _unloadServiceUrls(serviceGroup, services) {\n    // declare namespaces outside of loop\n    let existingService;\n\n    services.forEach((service) => {\n      existingService = this._getUrl(service.name, serviceGroup);\n\n      if (existingService) {\n        this.serviceGroups[serviceGroup].splice(\n          this.serviceGroups[serviceGroup].indexOf(existingService), 1\n        );\n      }\n    });\n\n    return this;\n  },\n\n  /**\n   * Search over all service groups to find a cluster id based\n   * on a given url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {string} - ClusterId of a given url\n   */\n  findClusterId(url) {\n    const incomingUrlObj = Url.parse(url);\n    let clusterId;\n    let serviceUrlObj;\n\n    for (const key of Object.keys(this.serviceGroups)) {\n      for (const service of this.serviceGroups[key]) {\n        serviceUrlObj = Url.parse(service.defaultUrl);\n\n        if (serviceUrlObj.hostname === incomingUrlObj.hostname &&\n          service.hosts.length > 0) {\n          clusterId = service.hosts[0].id;\n          break;\n        }\n\n        for (const host of service.hosts) {\n          if (incomingUrlObj.hostname === host.host && host.id) {\n            clusterId = host.id;\n            break;\n          }\n        }\n\n        if (clusterId) {\n          break;\n        }\n      }\n    }\n\n    return clusterId;\n  },\n\n  /**\n   * Search over all service groups and return a service value from a provided\n   * clusterId. Currently, this method will return either a service name, or a\n   * service url depending on the `value` parameter. If the `value` parameter\n   * is set to `name`, it will return a service name to be utilized within the\n   * Services plugin methods.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost = true] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  findServiceFromClusterId({clusterId, priorityHost = true, serviceGroup} = {}) {\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] : [\n        ...this.serviceGroups.postauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.discovery\n      ];\n\n    const identifiedServiceUrl = serviceUrls.find(\n      (serviceUrl) => serviceUrl.hosts.find(\n        (host) => host.id === clusterId\n      )\n    );\n\n    if (identifiedServiceUrl) {\n      return {\n        name: identifiedServiceUrl.name,\n        url: identifiedServiceUrl.get(priorityHost)\n      };\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Find a service based on the provided url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {serviceUrl} - ServiceUrl assocated with provided url\n   */\n  findServiceUrlFromUrl(url) {\n    const incomingUrlObj = Url.parse(url);\n    const serviceUrls = [\n      ...this.serviceGroups.discovery,\n      ...this.serviceGroups.preauth,\n      ...this.serviceGroups.signin,\n      ...this.serviceGroups.postauth\n    ];\n\n    return serviceUrls.find(\n      (serviceUrl) => {\n        if (incomingUrlObj.hostname ===\n          Url.parse(serviceUrl.defaultUrl).hostname) {\n          return true;\n        }\n\n        if (serviceUrl.hosts.find((host) => host.host === incomingUrlObj.hostname)) {\n          return true;\n        }\n\n        return false;\n      }\n    );\n  },\n\n  /**\n   * Get a service url from the current services list by name.\n   * @param {string} name\n   * @param {boolean} priorityHost\n   * @param {string} serviceGroup\n   * @returns {string}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const serviceUrl = this._getUrl(name, serviceGroup);\n\n    return (serviceUrl) ? serviceUrl.get(priorityHost) : undefined;\n  },\n\n  /**\n   * Creates an object where the keys are the service names\n   * and the values are the service urls.\n   * @param {boolean} priorityHost - use the highest priority if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const output = {};\n\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] :\n      [\n        ...this.serviceGroups.discovery,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.postauth\n      ];\n\n    if (serviceUrls) {\n      serviceUrls.forEach((serviceUrl) => {\n        output[serviceUrl.name] = serviceUrl.get(priorityHost);\n      });\n    }\n\n    return output;\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const serviceUrl = this._getUrl(Object.keys(this.list()).find(\n      (key) => this._getUrl(key).removeHost(url)\n    ));\n\n    if (!serviceUrl) {\n      return undefined;\n    }\n\n    return (noPriorityHosts) ? serviceUrl.get(false) : serviceUrl.get(true);\n  },\n\n  /**\n   * Update the current list of `ServiceUrl`s against a provided\n   * service hostmap.\n   * @emits ServiceCatalog#preauthorized\n   * @emits ServiceCatalog#postauthorized\n   * @param {string} serviceGroup\n   * @param {object} serviceHostmap\n   * @returns {Services}\n   */\n  updateServiceUrls(serviceGroup, serviceHostmap) {\n    const currentServiceUrls = this.serviceGroups[serviceGroup];\n\n    const unusedUrls = currentServiceUrls.filter(\n      (serviceUrl) => serviceHostmap.every(\n        (item) => item.name !== serviceUrl.name\n      )\n    );\n\n    this._unloadServiceUrls(serviceGroup, unusedUrls);\n\n    serviceHostmap.forEach((serviceObj) => {\n      const service = this._getUrl(serviceObj.name, serviceGroup);\n\n      if (service) {\n        service.defaultUrl = serviceObj.defaultUrl;\n        service.hosts = serviceObj.hosts || [];\n      }\n      else {\n        this._loadServiceUrls(serviceGroup, [new ServiceUrl({\n          ...serviceObj\n        })]);\n      }\n    });\n\n    this.status[serviceGroup].ready = true;\n    this.trigger(serviceGroup);\n\n    return this;\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject after a timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    return new Promise((resolve, reject) => {\n      if (this.status[serviceGroup].ready) {\n        resolve();\n      }\n\n      const timeoutTimer = setTimeout(() => reject(\n        new Error(`services: timeout occured while waiting for '${serviceGroup}' catalog to populate`)\n      ), (timeout) ? timeout * 1000 : 60000);\n\n      this.once(serviceGroup, () => {\n        clearTimeout(timeoutTimer);\n        resolve();\n      });\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default ServiceCatalog;\n"]}