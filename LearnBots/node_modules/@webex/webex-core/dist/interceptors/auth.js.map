{"version":3,"sources":["auth.js"],"names":["AuthInterceptor","options","headers","authorization","resolve","requiresCredentials","then","requires","webex","credentials","getUserToken","token","toString","service","resource","includes","uri","config","device","preDiscoveryServices","hydra","hydraServiceUrl","internal","isSpecificService","isHydra","isService","isServiceUrl","addAuthHeader","undefined","validateDomains","matchingDomains","whitelistedServiceDomains","filter","domain","length","reason","shouldAttemptReauth","logger","info","canRefresh","refresh","replay","reject","replayCount","maxAuthenticationReplays","error","Error","request","shouldRefreshAccessToken","statusCode","Interceptor"],"mappings":"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","file":"auth.js","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n/**\n * @class\n */\nexport default class AuthInterceptor extends Interceptor {\n  /**\n   * @returns {AuthInterceptor}\n   */\n  static create() {\n    return new AuthInterceptor({webex: this});\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    options.headers = options.headers || {};\n\n    // If Authorizations is already set, don't overwrite it\n    if ('authorization' in options.headers || 'auth' in options) {\n      // If Authorization is set to null, false, or undefined, delete it to\n      // prevent a CORS preflight.\n      if (!options.headers.authorization) {\n        Reflect.deleteProperty(options.headers, 'authorization');\n      }\n\n      return Promise.resolve(options);\n    }\n\n    return this.requiresCredentials(options)\n      .then((requires) => {\n        if (!requires) {\n          return options;\n        }\n\n        return this.webex.credentials.getUserToken()\n          .then((token) => {\n            options.headers.authorization = token.toString();\n\n            return options;\n          });\n      });\n  }\n\n  /**\n   * Determines if the provided options object needs an auth header\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  requiresCredentials(options) {\n    if (options.service === 'u2c') {\n      if (options.resource.includes('limited')) {\n        return Promise.resolve(false);\n      }\n\n      return Promise.resolve(true);\n    }\n\n    if (options.uri && (options.uri.includes(this.webex.config.device.preDiscoveryServices.hydra) ||\n      options.uri.includes(this.webex.config.device.preDiscoveryServices.hydraServiceUrl))) {\n      return Promise.resolve(true);\n    }\n\n    if (!this.webex.internal.device) {\n      return Promise.resolve(false);\n    }\n\n    return this.webex.internal.device.isSpecificService('hydra', options.uri)\n      .then((isHydra) => {\n        if (isHydra) {\n          return true;\n        }\n\n        if (options.service) {\n          return this.webex.internal.device.isService(options.service);\n        }\n        if (options.uri) {\n          // If service Url then return or else check if whitelisted\n          return this.webex.internal.device.isServiceUrl(options.uri)\n            .then((isServiceUrl) => {\n              if (isServiceUrl) {\n                return true;\n              }\n\n              if (options.addAuthHeader === undefined && this.webex.config.device.validateDomains) {\n                options.addAuthHeader = true;\n              }\n\n              // returns true if uri is in whitelistedServiceDomains and is requested\n              if (options.addAuthHeader) {\n                const matchingDomains = this.webex.config.device.whitelistedServiceDomains.filter((domain) => options.uri.includes(domain));\n\n                if (matchingDomains.length) {\n                  return Promise.resolve(true);\n                }\n              }\n\n              return false;\n            });\n        }\n\n        return false;\n      });\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    return this.shouldAttemptReauth(reason, options)\n      .then((shouldAttemptReauth) => {\n        if (shouldAttemptReauth) {\n          this.webex.logger.info('auth: received 401, attempting to reauthenticate');\n\n          if (reason.options.headers) {\n            Reflect.deleteProperty(reason.options.headers, 'authorization');\n          }\n\n          if (this.webex.credentials.canRefresh) {\n            return this.webex.credentials.refresh()\n              .then(() => this.replay(options));\n          }\n        }\n\n        return Promise.reject(reason);\n      });\n  }\n\n  /**\n   * Replays the request\n   * @param {Object} options\n   * @returns {Object}\n   */\n  replay(options) {\n    if (options.replayCount) {\n      options.replayCount += 1;\n    }\n    else {\n      options.replayCount = 1;\n    }\n\n    if (options.replayCount > this.webex.config.maxAuthenticationReplays) {\n      this.webex.logger.error(`auth: failed after ${this.webex.config.maxAuthenticationReplays} replay attempts`);\n\n      return Promise.reject(new Error(`Failed after ${this.webex.config.maxAuthenticationReplays} replay attempts`));\n    }\n\n    this.webex.logger.info(`auth: replaying request ${options.replayCount} time`);\n\n    return this.webex.request(options);\n  }\n\n  /**\n   * Indicates whether or not the current request should refresh its access\n   * token in event of a 401\n   * @param {Error} reason\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  shouldAttemptReauth(reason, options) {\n    if (options && options.shouldRefreshAccessToken === false) {\n      return Promise.resolve(false);\n    }\n\n    if (reason.statusCode === 401) {\n      return Promise.resolve(true);\n    }\n\n    return Promise.resolve(false);\n  }\n}\n"]}