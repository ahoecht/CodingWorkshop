{"version":3,"sources":["encryption.js"],"names":["Encryption","WebexPlugin","extend","children","kms","KMS","namespace","processKmsMessageEvent","event","decryptBinary","scr","buffer","then","b","length","byteLength","reject","Error","decrypt","decryptScr","key","cipherScr","options","getKey","k","SCR","fromJWE","jwk","decryptText","ciphertext","jose","JWE","createDecrypt","result","plaintext","toString","download","loc","shunt","EventEmitter","promise","_fetchDownloadUrl","uri","method","responseType","ret","request","res","body","logger","info","process","env","NODE_ENV","includes","resolve","inputBody","endpoints","service","resource","allow","params","url","warn","encryptBinary","file","create","encrypt","ensureBuffer","cdata","encryptScr","toJWE","encryptText","createEncrypt","config","joseOptions","header","alg","reference","final","onBehalfOf","asKey","storageKey","unboundedStorage","get","keyString","JSON","parse","keyObject","catch","fetchKey","put","replacer","v","json","toJSON"],"mappings":";;;;;;;;;;;;;;;;;;AAIA;;AAEA;;AACA;;AACA;;;;AACA;;;;AAEA;;;;AACA;;;;;;AAEA,IAAMA,aAAaC,uBAAYC,MAAZ,CAAmB;AACpCC,YAAU;AACRC,SAAKC;AADG,GAD0B;;AAKpCC,aAAW,YALyB;;AAOpCC,wBAPoC,kCAObC,KAPa,EAON;AAC5B,WAAO,KAAKJ,GAAL,CAASG,sBAAT,CAAgCC,KAAhC,CAAP;AACD,GATmC;AAWpCC,eAXoC,yBAWtBC,GAXsB,EAWjBC,MAXiB,EAWT;AACzB,WAAO,4BAAaA,MAAb,EACJC,IADI,CACC,UAACC,CAAD,EAAO;AACX;AACA,UAAIF,OAAOG,MAAP,KAAkB,CAAlB,IAAuBH,OAAOI,UAAP,KAAsB,CAAjD,EAAoD;AAClD,eAAO,kBAAQC,MAAR,CAAe,IAAIC,KAAJ,CAAU,yCAAV,CAAf,CAAP;AACD;;AAED,aAAOP,IAAIQ,OAAJ,CAAYL,CAAZ,CAAP;AACD,KARI,CAAP;AASD,GArBmC;;;AAuBpC;;;;;;;;;AASAM,YAhCoC,sBAgCzBC,GAhCyB,EAgCpBC,SAhCoB,EAgCTC,OAhCS,EAgCA;AAClC,WAAO,KAAKC,MAAL,CAAYH,GAAZ,EAAiBE,OAAjB,EACJV,IADI,CACC,UAACY,CAAD;AAAA,aAAOC,kBAAIC,OAAJ,CAAYF,EAAEG,GAAd,EAAmBN,SAAnB,CAAP;AAAA,KADD,CAAP;AAED,GAnCmC;;;AAqCpC;;;;;;;;;AASAO,aA9CoC,uBA8CxBR,GA9CwB,EA8CnBS,UA9CmB,EA8CPP,OA9CO,EA8CE;AACpC,WAAO,KAAKC,MAAL,CAAYH,GAAZ,EAAiBE,OAAjB,EACJV,IADI,CACC,UAACY,CAAD;AAAA,aAAOM,mBAAKC,GAAL,CACVC,aADU,CACIR,EAAEG,GADN,EAEVT,OAFU,CAEFW,UAFE,EAGVjB,IAHU,CAGL,UAACqB,MAAD;AAAA,eAAYA,OAAOC,SAAP,CAAiBC,QAAjB,EAAZ;AAAA,OAHK,CAAP;AAAA,KADD,CAAP;AAKD,GApDmC;;;AAsDpC;;;;;;;AAOAC,UA7DoC,oBA6D3B1B,GA7D2B,EA6DtBY,OA7DsB,EA6Db;AAAA;;AACrB;AACA,QAAI,CAACZ,IAAI2B,GAAT,EAAc;AACZ,aAAO,kBAAQrB,MAAR,CAAe,IAAIC,KAAJ,CAAU,uBAAV,CAAf,CAAP;AACD;;AAED,QAAMqB,QAAQ,IAAIC,oBAAJ,EAAd;AACA,QAAMC,UAAU,KAAKC,iBAAL,CAAuB/B,GAAvB,EAA4BY,OAA5B,EACbV,IADa,CACR,UAAC8B,GAAD,EAAS;AACb,UAAMpB,UAAU;AACdqB,gBAAQ,KADM;AAEdD,gBAFc;AAGdE,sBAAc;AAHA,OAAhB;;AAMA,UAAMC,MAAM,MAAKC,OAAL,CAAaxB,OAAb,CAAZ;;AAEA,kCAAe,UAAf,EAA2BA,QAAQc,QAAnC,EAA6CE,KAA7C;;AAEA,aAAOO,GAAP;AACD,KAba,EAcbjC,IAda,CAcR,UAACmC,GAAD;AAAA,aAAS,MAAKtC,aAAL,CAAmBC,GAAnB,EAAwBqC,IAAIC,IAA5B,CAAT;AAAA,KAdQ,CAAhB;;AAgBA,6BAAYV,KAAZ,EAAmBE,OAAnB;;AAEA,WAAOA,OAAP;AACD,GAvFmC;;;AAyFpC;;;;;;;AAOAC,mBAhGoC,6BAgGlB/B,GAhGkB,EAgGbY,OAhGa,EAgGJ;AAAA;;AAC9B,SAAK2B,MAAL,CAAYC,IAAZ,CAAiB,wDAAjB;;AAEA,QAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyC3C,IAAI2B,GAAJ,CAAQiB,QAAR,CAAiB,WAAjB,CAA7C,EAA4E;AAC1E,WAAKL,MAAL,CAAYC,IAAZ,CAAiB,qFAAjB;;AAEA,aAAO,kBAAQK,OAAR,CAAgB7C,IAAI2B,GAApB,CAAP;AACD;;AAED,QAAMmB,YAAY;AAChBC,iBAAW,CAAC/C,IAAI2B,GAAL;AADK,KAAlB;;AAIA,WAAO,KAAKS,OAAL,CAAa;AAClBH,cAAQ,MADU;AAElBe,eAAS,OAFS;AAGlBC,gBAAU,oBAHQ;AAIlBX,YAAM1B,qCACDkC,SADC;AAEJI,eAAOtC,QAAQuC,MAAR,CAAeD;AAFlB,WAGFJ;AAPc,KAAb,EASJ5C,IATI,CASC,UAACmC,GAAD,EAAS;AACb,UAAMe,MAAMf,IAAIC,IAAJ,CAASS,SAAT,CAAmB/C,IAAI2B,GAAvB,CAAZ;;AAEA,UAAI,CAACyB,GAAL,EAAU;AACR,eAAKb,MAAL,CAAYc,IAAZ,CAAiB,uGAAjB;;AAEA,eAAOrD,IAAI2B,GAAX;AACD;AACD,aAAKY,MAAL,CAAYC,IAAZ,CAAiB,uDAAjB;;AAEA,aAAOY,GAAP;AACD,KApBI,CAAP;AAqBD,GAlImC;AAoIpCE,eApIoC,yBAoItBC,IApIsB,EAoIhB;AAClB,WAAO,4BAAaA,IAAb,EACJrD,IADI,CACC,UAACD,MAAD;AAAA,aAAYc,kBAAIyC,MAAJ,GACftD,IADe,CACV,UAACF,GAAD;AAAA,eAASA,IAAIyD,OAAJ,CAAYxD,MAAZ,EACZC,IADY,CACPwD,sBADO;AAEb;AAFa,SAGZxD,IAHY,CAGP,UAACyD,KAAD;AAAA,iBAAY,EAAC3D,QAAD,EAAM2D,YAAN,EAAZ;AAAA,SAHO,CAAT;AAAA,OADU,CAAZ;AAAA,KADD,CAAP;AAMD,GA3ImC;;;AA6IpC;;;;;;;;;AASAC,YAtJoC,sBAsJzBlD,GAtJyB,EAsJpBV,GAtJoB,EAsJfY,OAtJe,EAsJN;AAC5B;AACA,QAAI,CAACZ,IAAI2B,GAAT,EAAc;AACZ,aAAO,kBAAQrB,MAAR,CAAe,IAAIC,KAAJ,CAAU,kDAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKM,MAAL,CAAYH,GAAZ,EAAiBE,OAAjB,EACJV,IADI,CACC,UAACY,CAAD;AAAA,aAAOd,IAAI6D,KAAJ,CAAU/C,EAAEG,GAAZ,CAAP;AAAA,KADD,CAAP;AAED,GA9JmC;;;AAgKpC;;;;;;;;;AASA6C,aAzKoC,uBAyKxBpD,GAzKwB,EAyKnBc,SAzKmB,EAyKRZ,OAzKQ,EAyKC;AAAA;;AACnC,WAAO,KAAKC,MAAL,CAAYH,GAAZ,EAAiBE,OAAjB,EACJV,IADI,CACC,UAACY,CAAD;AAAA,aAAOM,mBAAKC,GAAL,CACV0C,aADU,CACI,OAAKC,MAAL,CAAYC,WADhB,EAC6B;AACtCvD,aAAKI,EAAEG,GAD+B;AAEtCiD,gBAAQ;AACNC,eAAK;AADC,SAF8B;AAKtCC,mBAAW;AAL2B,OAD7B,EAQVC,KARU,CAQJ7C,SARI,EAQO,MARP,CAAP;AAAA,KADD,CAAP;AAUD,GApLmC;;;AAsLpC;;;;;;;;AAQAX,QA9LoC,kBA8L7BmB,GA9L6B,EA8LL;AAAA;;AAAA,mFAAJ,EAAI;AAAA,QAAlBsC,UAAkB,QAAlBA,UAAkB;;AAC7B,QAAItC,IAAIf,GAAR,EAAa;AACX,aAAO,KAAKvB,GAAL,CAAS6E,KAAT,CAAevC,GAAf,CAAP;AACD;;AAED,QAAIwC,aAAaxC,GAAjB;;AAEA,QAAIsC,UAAJ,EAAgB;AACdE,qCAA6BF,UAA7B;AACD;;AAED,WAAO,KAAKG,gBAAL,CAAsBC,GAAtB,CAA0BF,UAA1B,EACJtE,IADI,CACC,UAACyE,SAAD;AAAA,aAAeC,KAAKC,KAAL,CAAWF,SAAX,CAAf;AAAA,KADD,EAEJzE,IAFI,CAEC,UAAC4E,SAAD;AAAA,aAAe,OAAKpF,GAAL,CAAS6E,KAAT,CAAeO,SAAf,CAAf;AAAA,KAFD,EAGJC,KAHI,CAGE;AAAA,aAAM,OAAKrF,GAAL,CAASsF,QAAT,CAAkB,EAAChD,QAAD,EAAMsC,sBAAN,EAAlB,EACVpE,IADU,CACL,iBAAI,UAACQ,GAAD;AAAA,eAAS,OAAK+D,gBAAL,CAAsBQ,GAAtB,CAA0BT,UAA1B,EAAsC,yBAAe9D,GAAf,EAAoBwE,QAApB,CAAtC,CAAT;AAAA,OAAJ,CADK,CAAN;AAAA,KAHF,CAAP;AAKD,GA9MmC;AAAA;AAAA,CAAnB,CAAnB;;AAiNA;;;;;;AA/NA;;;;AAqOA,SAASA,QAAT,CAAkBpE,CAAlB,EAAqBqE,CAArB,EAAwB;AACtB,MAAIrE,MAAM,KAAV,EAAiB;AACf;AACA;AACA,QAAMsE,OAAO,KAAKtE,CAAL,EAAQuE,MAAR,CAAe,IAAf,CAAb;;AAEA,WAAOD,IAAP;AACD;;AAED,SAAOD,CAAP;AACD;;kBAEc7F,U","file":"encryption.js","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\n\nimport {WebexPlugin} from '@webex/webex-core';\nimport {proxyEvents, tap, transferEvents} from '@webex/common';\nimport jose from 'node-jose';\nimport SCR from 'node-scr';\n\nimport ensureBuffer from './ensure-buffer';\nimport KMS from './kms';\n\nconst Encryption = WebexPlugin.extend({\n  children: {\n    kms: KMS\n  },\n\n  namespace: 'Encryption',\n\n  processKmsMessageEvent(event) {\n    return this.kms.processKmsMessageEvent(event);\n  },\n\n  decryptBinary(scr, buffer) {\n    return ensureBuffer(buffer)\n      .then((b) => {\n        /* istanbul ignore if */\n        if (buffer.length === 0 || buffer.byteLength === 0) {\n          return Promise.reject(new Error('Attempted to decrypt zero-length buffer'));\n        }\n\n        return scr.decrypt(b);\n      });\n  },\n\n  /**\n   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} cipherScr - An encrypted SCR\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {Object} Decrypted SCR\n   */\n  decryptScr(key, cipherScr, options) {\n    return this.getKey(key, options)\n      .then((k) => SCR.fromJWE(k.jwk, cipherScr));\n  },\n\n  /**\n   * Decrypt text using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} ciphertext - Encrypted text\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Decrypted plaintext\n   */\n  decryptText(key, ciphertext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createDecrypt(k.jwk)\n        .decrypt(ciphertext)\n        .then((result) => result.plaintext.toString()));\n  },\n\n  /**\n   * Validate and initiate a Download request for requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise}\n   */\n  download(scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('`scr.loc` is required'));\n    }\n\n    const shunt = new EventEmitter();\n    const promise = this._fetchDownloadUrl(scr, options)\n      .then((uri) => {\n        const options = {\n          method: 'GET',\n          uri,\n          responseType: 'buffer'\n        };\n\n        const ret = this.request(options);\n\n        transferEvents('progress', options.download, shunt);\n\n        return ret;\n      })\n      .then((res) => this.decryptBinary(scr, res.body));\n\n    proxyEvents(shunt, promise);\n\n    return promise;\n  },\n\n  /**\n   * Fetch Download URL for the requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise} url of the downloadable file\n   */\n  _fetchDownloadUrl(scr, options) {\n    this.logger.info('encryption: retrieving download url for encrypted file');\n\n    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {\n      this.logger.info('encryption: bypassing webex files because this looks to be a test file on localhost');\n\n      return Promise.resolve(scr.loc);\n    }\n\n    const inputBody = {\n      endpoints: [scr.loc]\n    };\n\n    return this.request({\n      method: 'POST',\n      service: 'files',\n      resource: 'download/endpoints',\n      body: options ? {\n        ...inputBody,\n        allow: options.params.allow\n      } : inputBody\n    })\n      .then((res) => {\n        const url = res.body.endpoints[scr.loc];\n\n        if (!url) {\n          this.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');\n\n          return scr.loc;\n        }\n        this.logger.info('encryption: retrieved download url for encrypted file');\n\n        return url;\n      });\n  },\n\n  encryptBinary(file) {\n    return ensureBuffer(file)\n      .then((buffer) => SCR.create()\n        .then((scr) => scr.encrypt(buffer)\n          .then(ensureBuffer)\n          // eslint-disable-next-line max-nested-callbacks\n          .then((cdata) => ({scr, cdata}))));\n  },\n\n  /**\n   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} scr - Plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted SCR\n   */\n  encryptScr(key, scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));\n    }\n\n    return this.getKey(key, options)\n      .then((k) => scr.toJWE(k.jwk));\n  },\n\n  /**\n   * Encrypt plaintext using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted text\n   */\n  encryptText(key, plaintext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createEncrypt(this.config.joseOptions, {\n          key: k.jwk,\n          header: {\n            alg: 'dir'\n          },\n          reference: null\n        })\n        .final(plaintext, 'utf8'));\n  },\n\n  /**\n   * Fetch the key associated with the supplied KMS uri.\n   *\n   * @param {string} uri - The uri of a key stored in KMS\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Key\n   */\n  getKey(uri, {onBehalfOf} = {}) {\n    if (uri.jwk) {\n      return this.kms.asKey(uri);\n    }\n\n    let storageKey = uri;\n\n    if (onBehalfOf) {\n      storageKey += `/onBehalfOf/${onBehalfOf}`;\n    }\n\n    return this.unboundedStorage.get(storageKey)\n      .then((keyString) => JSON.parse(keyString))\n      .then((keyObject) => this.kms.asKey(keyObject))\n      .catch(() => this.kms.fetchKey({uri, onBehalfOf})\n        .then(tap((key) => this.unboundedStorage.put(storageKey, JSON.stringify(key, replacer)))));\n  }\n});\n\n/**\n * JSON.stringify replacer that ensures private key data is serialized.\n * @param {string} k\n * @param {mixed} v\n * @returns {mixed}\n */\nfunction replacer(k, v) {\n  if (k === 'jwk') {\n    // note: this[k] and v may be different representations of the same value\n    // eslint-disable-next-line no-invalid-this\n    const json = this[k].toJSON(true);\n\n    return json;\n  }\n\n  return v;\n}\n\nexport default Encryption;\n"]}